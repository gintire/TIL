# Mockito

Mockito는 JUnit 위에서 동작하며 Mocking과 Verification을 도와주는 프레임워크이다.
## 차별점
1. 테스트 그 자체에 집중
2. 테스트 스텁을 만드는 것과 검증을 분리
3. Mock 만드는 방법을 단일화
4. 테스트 스텁을 만들기 쉬움
5. API가 간단
6. 프레임워크가 지원해주지 않으면 안되는 코드를 최대한 배제
7. 실패 시에 발생하는 에러추적이 깔끔

## 기본 사용법
Mockito는 Stub 작성과 Verify가 중심을 이루며 다음과 같은 순서로 진행
1. CreateMock : 인터페이스에 해당하는 Mock 객체를 만든다.
2. Stub : 테스트에 필요한 Mock 객체의 동작을 지정
3. Exercise : 테스트 메소드 내에서 Mock 객체를 사용한다.
4. Verify : 메소드가 예상대로 호출됐는지 검증

## 주요 요소
* mock() / @Mock : mock을 생성
  * 선택적으로 Answer / MockSettings를 통해 작동 방식을 지정
  * mock이 어떻게 동작하는지 when() / given()을 통해 지정
  * 제공된 answers이 필요에 맞지 않으면, Answer 인터페이스를 확장해서 직접 작성
* spy() / @Spy : 특정 mocking, 실제 메서드가 호출되지만, verified와 stubbed을 사용할 수 있음
* InjectMocks : @Spy 또는 @Mock 주석이 달린 mocks / spied 필드 자동 삽입
* verify() :  주어진 인수로 메서드가 호출되었는지 확인
  * 유연한 인수 일치를 사용할 수 있음. 예를 들어 any()를 통해 any 표현을 사용 가능
  * 또는 대신 @Captor를 사용하여 호출 된 인수 캡처
* BDD Mockito를 통해 Behavior-Driven development 문법 사용

## Test Double
테스팅에서 실제 객체를 대신하여 사용되는 모든 방법  
실제 객체를 사용하기 어렵고 모호할 때, 이를 대신해줄 객체를 만들어 테스트 수행을 돕는다.    
**`Dummy`**   
Dummy 객체는 전달되기만하고 실제 사용되지는 않음  
단지 인스턴스화된 객체가 필요한 경우 ( 해당 객체의 기능이 필요하지 않을 때 )  
**`Fake`**  
Fake 객체는 실제로 동작하는 구현체가 있으나, 운영시에는 사용할 수 없는 간단한 형태  
여러개의 인스턴스를 대표할 수 있는 경우  
보통 List나 Map을 이용하여 DB 같은 외부 의존 환경을 대체한다.   
즉, *복잡한 로직 or 외부 서비스의 동작을 비교적 단순화하여 구현한 객체*  
**`Stub`**  
Dummy 객체가 마치 실제로 동작하는 것처럼 보이게 만들어 놓은 객체  
Stub는 테스트 시 호출되면 미리 준비된 Answers로 응답하므로 테스트에 사용하기 위해 미리 프로그램된 것 이외의 것에 대해서는 응답하지 않는다.   
**`Spy`**   
Stub의 역할을 가지면서 호출된 내용에 대해 테스트에서 확인하기 위한 약간의 정보를 기록하는 객체이다.  
호출 여부를 감시해서 기록했다가 나중에 요청이 들어오면 해당 기록 정보를 전달해 준다.  
기록 정보 : 특정 객체가 사용됐는가? 그 객체의 예상된 메소드가 정상적으로 호출됐는가?    
**`Mock`**  
Mock 객체는 호출에 대한 기대를 명세하고, 해당 내용에 따라 동작하도록 프로그래밍 된 객체

## Mock
상태 기반 테스트 vc 행위 기반 테스트
* 상태 기반 테스트
  * 특정 메소드를 거친 후 객체의 상태에 대해 예상값과 비교
* 행위 기반 테스트
  * 특정한 동작이 수행됐는가 여부를 확인
  * 메소드 리턴값이 없거나, 리턴값의 확인으로 예상대로 동작함을 보장할 수 없는 경우 사용
  * ex> 로직 : 특정 argument에 대해 A인 경우에는 methodA가 호출, methodB는 호출 되지 않음
  * 이때 argument A에 대해 어떤 메소드가 호출되고 호출되지 않는지 판단
  * 즉, 행위를 점검하는 것으로 테스트 케이스를 만듬
  * 예상하는 행위들을 미리 시나리오로 만들어 놓고 해당 시나리오대로 동작했는지 여부를 확인하는 것이 핵심
### @Mock
🕶[Mock 예제](./UserTest.java)  
일반적인 테스트 더블은 상태를 기반으로 테스트 케이스를 작성
Mock 객체는 행위를 기반으로 테스트 케이스를 작성
### @Spy
🕶[Spy 예제](./UserSpyTest.java)  
실제 객체를 Mock으로 만들어 사용할 수 있다.  
일반 인스턴스와 동일한 방식으로 동작한다.  
일반 인스턴스와의 유일한 차이점은 모든 상호 작용을 추적하도록 계측된다는 것이다.  
부분 Mocking이라는 방법으로 서드파티 제품, 고칠 수 없는 라이브러리만 남아있는 코드 등에 대해서만 한정적으로 사용하는 것을 권장  
Mockito의 저자는 spy기능을 쓰게되면 그건 이미 잘못된 코드를 건드리고 있는 증거라고 말함  
### @InjectMocks
🕶[InjectMock 예제](./UserStubTest.java)
mock / spy 객체를 주입한다.  
Mockito는 생성자 주입, setter 주입, property 주입에 의해 순차적으로 mock 주입을 시도
### verify() 
🕶[Verify 예제](./UserStubTest.java)
특정 메소드의 호출에 대해 확인
### Stubbing
🕶[Stub 예제](./UserStubTest.java)  
테스트 작성자가 정해둔 행위로 실제 행위가 대치되는 것을 뜻함

## void가 리턴값이 mock 테스트
doNothing()은 Mockito의 void 메서드에 대한 기본 설정이다.
- doAnswer() : void를 반환하는 모의 객체 메서드가 호출 될 때이를 사용하여 일부 작업을 수행 할 수 있습니다. 
- doThrow() : 예외를 발생시키는 void 메서드를 stub하려면 doThrow ()를 사용할 수 있습니다.
